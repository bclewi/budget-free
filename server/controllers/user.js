/*
======================================================
User controller
======================================================
*/

// Module dependencies
const bcrypt = require('bcrypt');

// Model dependencies
const db = require('../models/db');

/*
Sequelize Operators for queries
https://sequelize.org/master/variable/index.html#static-variable-Op
*/
const Op = db.Sequelize.Op;

/* 
----------------
CREATE USER
----------------
*/
exports.createUser = async (req, res) => {
  const { username, email, password, firstName, lastName, subscription } = req.body;
  // request validation handled by validateResource() middleware

  // Validate Availability of Credentials 
  const credentialsTaken = await db.users.findOne({
    where: {
      [Op.or]: [
        { username: username },
        { email: email }
      ]
    }
  });
  if (credentialsTaken) {
    console.log('The credentials provided are already associated with an account.');
    return res.status(400).send({ message: 'The credentials provided are already associated with an account.' });
  }

  console.log('\n[User Controller] Signing up...');

  // Enrypt password
  const hash = await bcrypt.hash(password, 10);

  // Create user object
  const user = {
    // id is an autogenerated UUIDv4
    email: email,
    password_hash: hash,
    username: username,
    first_name: firstName,
    last_name: lastName,
    subscription: subscription
  };

  // Save user to database
  const newUser = await db.users.create(user);
  if (!newUser) {
    console.log('[User Controller] Failed: Could not sign up the new user.');
    return res.status(500).send('Could not sign up the new user.');
  }
  console.log('[User Controller] Done: Signed up new user.');
  return res.status(200).json({ id: newUser.id });

}

/* 
----------------
READ SELF
----------------
*/
exports.getUser = async (req, res) => {
  // user is valid, exists, and has permission to itself if requireAuth() middleware passes to next()

  // perform request
  console.log('\n[User Controller] Getting user...');
  const userRes = await db.users.findOne({
    where: {
      id: req.session.passport.user // id of active session
    }
  });
  if (!userRes) {
    return res.status(404).send('[User Controller] Failed: The requested user could not be found');
  }
  const { id, email, username, first_name, last_name, subscription, default_budget_id } = userRes.dataValues;
  console.log('[User Controller] Done');
  res.status(200).send({
    id: id,
    email: email,
    username: username,
    firstName: first_name,
    lastName: last_name,
    subscription: subscription,
    defaultBudgetId: default_budget_id
  });
};

/* 
----------------
UPDATE SELF
----------------
*/
exports.updateUser = async (req, res) => {
  const { firstName, lastName, email, username, password, subscription, defaultBudgetId } = req.body;

  // validate request
  /*
  if (!firstName && !lastName && !email && !username && !password && !subscription && !defaultBudgetId) {
    console.log('[User Controller] Invalid Request: at least one of the following properties is required to update a user: firstName, lastName, email, userName, password, subscription, defaultBudgetId');
    return res.status(400).send('at least one of the following properties is required to update a user: firstName, lastName, email, userName, password, subscription, defaultBudgetId');
  }
  
  if (
    (firstName && firstName.length > 255) || 
    (lastName && lastName.length > 255) || 
    (email && email.length > 255) || 
    (username && username.length > 255) || 
    (password && password.length > 255) || 
    (defaultBudgetId && defaultBudgetId > 255)
    ) {
    console.log('[User Controller] Invalid Request: properties must not exceed 255 characters');
    return res.status(400).send('properties must not exceed 255 characters');
  }
  if (
    (firstName && firstName.length < 2) || 
    (lastName && lastName.length < 2)
    ) {
    console.log('[User Controller] Invalid Request: length of firstName and lastName properties must be at least 2 characters');
    return res.status(400).send('length of firstName and lastName properties must be at least 2 characters');
  }
  if ((email && email.length < 8) || 
  (username && username.length < 8)) {
    console.log('[User Controller] Invalid Request: length of email and username properties must be at least 8 characters');
    return res.status(400).send('length of email and username properties must be at least 8 characters');
  }
  if (subscription && subscription !== true && subscription !== false) {
    console.log('[User Controller] Invalid Request: subscription must be a boolean value');
    return res.status(400).send('subscription must be a boolean value');
  }
  */

  // check if resource(s) referenced exist
  let defaultBudget;
  if (defaultBudgetId) {
    defaultBudget = await db.budgets.findOne({
      where: {
        id: defaultBudgetId
      }
    });
    if (!defaultBudget) {
      console.log('[User Controller] Failed: The requested budget could not be found');
      return res.status(404).send('The requested budget could not be found');
    }
  }

  // validate permissions
  if (defaultBudgetId) {
    const budgetIdsPermitted = [];
    res.locals.perms.map(perm => {
      budgetIdsPermitted.push(perm.budgetId);
    });
    const permGranted = budgetIdsPermitted.includes(defaultBudgetId);
    if (!permGranted) {
      console.log('[User Controller] Permission to the requested resource denied.');
      return res.status(401).send('Permission to the requested resource denied.');
    }
  }

  // Validate Availability of Credentials
  if (username || email) {
    let credentials;
    if (username) credentials = username;
    else if (email) credentials = email;
    const credentialsTaken = await db.users.findOne({
      where: {
        [Op.or]: [
          { username: credentials },
          { email: credentials }
        ]
      }
    });
    if (credentialsTaken) {
      console.log('The requested username and/or email is already associated with an account.');
      return res.status(400).send('The requested username and/or email is already associated with an account.');
    }
  }
  

  // perform request

  // Enrypt password
  let hash;
  if (password) hash = await bcrypt.hash(req.body.password, 10);

  const updateRes = await db.users.update(
    {
      first_name: firstName,
      last_name: lastName,
      email: email,
      username: username,
      password_hash: hash,
      subscription: subscription,
      default_budget_id: defaultBudgetId
    }, 
    { where: { id: req.session.passport.user } } // id of active session
  );
  if (!updateRes) {
    console.log('[User Controller] Error: The requested resource could not be updated');
    return res.status(500).send();
  }
  return res.status(204).send(); // no content
};

/* 
----------------
DELETE SELF
----------------
*/
exports.deleteUser = async (req, res) => {

  // validate request
  if (!req.params.userIdConfirmation) {
    console.log('[User Controller] Invalid Request: userIdConfirmation is required to delete a user');
    return res.status(400).send('userIdConfirmation is required to delete a user');
  }
  if (req.session.passport.user !== req.params.userIdConfirmation) {
    console.log('[User Controller] Invalid Request: userIdConfirmation must be the id of the authorized user');
    return res.status(400).send('userIdConfirmation must be the id of the authorized user');
  }

  // user exists and has own permission if requireAuth() middleware passed to next()

  // perform request
  const deleteRes = await db.users.destroy({ 
    where: { 
      id: req.session.passport.user // id of active session
    } 
  }); 
  if (!deleteRes) {
    console.log('[User Controller] Error: The requested resource could not be deleted');
    return res.status(500).send();
  }
  return res.status(204).send(); // no content
};